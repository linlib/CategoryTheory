texttt{.lean file}}

  }}



pagecolor{Purple}

begin{center}

 
 
 
 

def n : Int := 1


def reflexivity {X : Type} {x : X} (p : x = x) := Eq.refl p
def symmetry {X : Type} {x : X} {y : X}  (p : x = y) := Eq.symm p
def transitivity {X : Type} {x : X} {y : X} {z : X} (p : x = y) (q : y = z) := Eq.trans p q
notation p "|" q => transitivity p q


def extensionality (f g : X ‚Üí Y) (p : (x:X) ‚Üí f x = g x) : f = g := funext p


def equal_arguments {X : Type} {Y : Type} {a : X} {b : X} (f : X ‚Üí Y) (p : a = b) : f a = f b := congrArg f p

def equal_functions {X : Type} {Y : Type} {f‚ÇÅ : X ‚Üí Y} {f‚ÇÇ : X ‚Üí Y} (p : f‚ÇÅ = f‚ÇÇ) (x : X) : f‚ÇÅ x = f‚ÇÇ x := congrFun p x


-- A category C consists of:
structure category where
  Obj : Type u
  Hom : Obj ‚Üí Obj ‚Üí Type v
  Idn : (X:Obj) ‚Üí Hom X X
  Cmp : (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (_:Hom X Y) ‚Üí (_:Hom Y Z) ‚Üí Hom X Z
  Id‚ÇÅ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí 
    Cmp X Y Y f (Idn Y) = f
  Id‚ÇÇ : (X:Obj) ‚Üí (Y:Obj) ‚Üí (f:Hom X Y) ‚Üí 
    Cmp X X Y (Idn X) f = f
  Ass : (W:Obj) ‚Üí (X:Obj) ‚Üí (Y:Obj) ‚Üí (Z:Obj) ‚Üí (f:Hom W X) ‚Üí (g:Hom X Y) ‚Üí (h:Hom Y Z) ‚Üí
    (Cmp W X Z) f (Cmp X Y Z g h) = Cmp W Y Z (Cmp W X Y f g) h


-- Notation for the identity map which infers the category:
def identity_map {C : category} (X : C.Obj) := C.Idn X
notation "ùüô" => identity_map

-- Notation for the domain of a morphism:
def Dom {C : category} {X : C.Obj} {Y : C.Obj} (_ : C.Hom X Y) := X

-- Notation for the codomain of a morphism:
def Cod {C : category} {X : C.Obj} {Y : C.Obj} (_ : C.Hom X Y) := X

-- Notation for composition which infers the category and objects:
def composition {C : category} {X : C.Obj} {Y : C.Obj} {Z : C.Obj} (f : C.Hom X Y) (g : C.Hom Y Z) : C.Hom X Z := C.Cmp X Y Z f g
notation g "‚àò" f => composition f g


-- obtaining a morphism from an equality
def Map {C : category} {X : C.Obj} {Y : C.Obj} (p : X = Y) : C.Hom X Y := by
subst p
exact C.Idn X


-- definition of an isomorphism from X to Y
structure isomorphism {C : category} (X : C.Obj) (Y : C.Obj) where
  Fst : C.Hom X Y
  Snd : C.Hom Y X
  Id‚ÇÅ : (Fst ‚àò Snd) = ùüô Y
  Id‚ÇÇ : (Snd ‚àò Fst) = ùüô X


-- notation for isomorphisms from X to Y (‚âÖ)
notation X "‚âÖ" Y => isomorphism X Y


-- defining the inverse of an isomorphism between objects X and Y
def inverse {C : category} {X : C.Obj} {Y : C.Obj} (f : X ‚âÖ Y) : Y ‚âÖ X := {Fst := f.Snd, Snd := f.Fst, Id‚ÇÅ := f.Id‚ÇÇ, Id‚ÇÇ := f.Id‚ÇÅ}


-- notation for inverse : isos from X to Y to isos from Y to X
notation f "‚Åª¬π" => inverse f


-- defining the objects of the category Set
def SetObj : Type 1 := Type

-- defining the morphisms of the category Set
def SetHom (X : SetObj) (Y : SetObj) : Type := X ‚Üí Y

-- defining the identity morphism of an object in the category Set
def SetIdn (X : SetObj) : SetHom X X := Œª (x : X) => x

--  defining composition in the category Set
def SetCmp (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom X Y) (g : SetHom Y Z) : (SetHom X Z) := Œª (x : X) => (g (f x)) 


-- proving the first identity law for composition in Set
def SetId‚ÇÅ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : SetCmp X Y Y f (SetIdn Y) = f := sorry

-- proving the second identity law for composition in Set
def SetId‚ÇÇ (X : SetObj) (Y : SetObj) (f : SetHom X Y) : SetCmp X X Y (SetIdn X) f = f := sorry

-- proving the associativity law for composition in Set
def SetAss (W : SetObj) (X : SetObj) (Y : SetObj) (Z : SetObj) (f : SetHom W X) (g : SetHom X Y) (h : SetHom Y Z) : SetCmp W X Z f (SetCmp X Y Z g h) = SetCmp W Y Z (SetCmp W X Y f g) h := sorry


-- defining the category Set
def Set : category := {Obj := SetObj, Hom := SetHom, Idn := SetIdn, Cmp := SetCmp, Id‚ÇÅ := SetId‚ÇÅ, Id‚ÇÇ := SetId‚ÇÇ, Ass := SetAss}


-- definition of a functor
structure functor (C : category) (D : category) where
   Obj : ‚àÄ(_ : C.Obj),D.Obj
   Hom : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(_ : C.Hom X Y),D.Hom (Obj X) (Obj Y)
   Idn : ‚àÄ(X : C.Obj),Hom X X (C.Idn X) = D.Idn (Obj X)
   Cmp : ‚àÄ(X : C.Obj),‚àÄ(Y : C.Obj),‚àÄ(Z : C.Obj),‚àÄ(f : C.Hom X Y),‚àÄ(g : C.Hom Y Z),
   D.Cmp (Obj X) (Obj Y) (Obj Z) (Hom X Y f) (Hom Y Z g) = Hom X Z (C.Cmp X Y Z f g)


-- notation for the type of Hom from a category C to a category D
notation C "‚ûû" D => functor C D


-- Notation for the domain of a functor:
def domain {C : category} {X : C.Obj} {Y : C.Obj} (_ : C.Hom X Y) := X
notation "ùóóùóºùó∫" => domain


-- Notation for the domain of a functor:
def codomain {C : category} {X : C.Obj} {Y : C.Obj} (_ : C.Hom X Y) := Y
notation "ùóñùóºùó±" => codomain


-- definition of the identity functor on objects
def CatIdnObj (C : category) := 
fun(X : C.Obj)=>
X

-- definition of the identity functor on morphisms
def CatIdnMor (C : category) := 
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
f

-- proving the identity law for the identity functor
def CatIdnIdn (C : category) := 
fun(X : C.Obj)=>
Eq.refl (ùüô X)

-- proving the compositionality law for the identity functor 
def CatIdnCmp (C : category) := 
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
Eq.refl (g ‚àò f)

-- defining the identity functor
def CatIdn (C : category) : functor C C := 
{Obj := CatIdnObj C, Hom := CatIdnMor C, Idn := CatIdnIdn C, Cmp := CatIdnCmp C}


-- notation for the identity functor
notation "ùü≠" => CatIdn


-- defining the composition G ‚àò F on objects
def CatCmpObj (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) := 
fun(X : C.Obj)=>
(G.Obj (F.Obj X))

-- defining the composition G ‚àò F on morphisms
def CatCmpHom (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) := 
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(f : C.Hom X Y)=>
(G.Hom) (F.Obj X) (F.Obj Y) (F.Hom X Y f)

-- proving the identity law for the composition G ‚àò F
def CatCmpIdn (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) := 
fun(X : C.Obj)=> 
(congrArg (G.Hom (F.Obj X) (F.Obj X)) (F.Idn X) ) | (G.Idn (F.Obj X))

-- proving the compositionality law for the composition G ‚àò F
def CatCmpCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) := 
fun(X : C.Obj)=>
fun(Y : C.Obj)=>
fun(Z : C.Obj)=>
fun(f : C.Hom X Y)=>
fun(g : C.Hom Y Z)=>
((Eq.trans) 
(G.Cmp (F.Obj X) (F.Obj Y) (F.Obj Z) (F.Hom X Y f) (F.Hom Y Z g)) 
(congrArg (G.Hom  (F.Obj X) (F.Obj Z)) (F.Cmp X Y Z f g)))

-- defining the composition in the category Cat
def CatCmp (C : category) (D : category) (E : category) (F : functor C D) (G : functor D E) : functor C E := 
{Obj := CatCmpObj C D E F G, Hom := CatCmpHom C D E F G,Idn := CatCmpIdn C D E F G, Cmp := CatCmpCmp C D E F G }


-- notation for the composition in the category Cat
def functor_composition {C : category} {D : category} {E : category} (F : functor C D) (G : functor D E) : functor C E := CatCmp C D E F G
notation G "‚Ä¢" F => functor_composition F G
/-
-- this should be able to handle F ‚Ä¢ X or F ‚Ä¢ G
-/


-- proving Cat.Id‚ÇÅ
def CatId‚ÇÅ (C : category) (D : category) (F : functor C D) : ((CatCmp C D D) F (CatIdn D) = F) := Eq.refl F


-- Proof of Cat.Id‚ÇÇ
def CatId‚ÇÇ (C : category) (D : category) (F : functor C D) : ((CatCmp C C D) (CatIdn C) F = F) := Eq.refl F


-- Proof of Cat.Ass
def CatAss (B : category) (C : category) (D : category) (E : category) (F : functor B C) (G : functor C D) (H : functor D E) : (CatCmp B C E F (CatCmp C D E G H) = CatCmp B D E (CatCmp B C D F G) H) := 
Eq.refl (CatCmp B C E F (CatCmp C D E G H))


-- The category of categories
def Cat : category := {Obj := category, Hom := functor, Idn := CatIdn, Cmp := CatCmp, Id‚ÇÅ:= CatId‚ÇÅ, Id‚ÇÇ:= CatId‚ÇÇ, Ass := CatAss}


/-
def OppObjObj (C : category) := C.Obj
def OppObjHom (C : category) (X : OppObjObj) (Y : OppObjObj) := C.Hom Y X
def OppObjIdn (C : category) (X : OppObjObj) := C.Idn X
def OppObjCmp (C : category) (X : OppObjObj) (Y : OppObjObj) (Z : OppObjObj) (f : OppObjHom X Y) (g : OppObjHom Y Z) : OppObjHom X Z := 
-/
-- def OppObj (C : category) : category := {Obj := OppObjObj, Hom := OppObjHom, Idn := OppObjIdn, Cmp := OppObjCmp}


/-
def OppHomObj (C : category) (D : category) (F : functor C D) 
def OppHomHom (C : category) (D : category) (F : functor C D) 
def OppHomIdn (C : category) (D : category) (F : functor C D) 
def OppHomCmp (C : category) (D : category) (F : functor C D) 
def OppHom (C : category) (D : category) (F : functor C D) 
-/


/-
def OppIdn
-/


/-
def OppCmp
-/


def Opp : Cat ‚ûû Cat := sorry --{}


notation C "·µí·µñ" => Opp.Obj C


-- defining the objects of the Prd C √ó D
def PrdObjObj (C : category) (D : category) := (C.Obj) √ó (D.Obj)

-- defining the morphisms of C √ó D
def PrdObjHom (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) := (C.Hom X.1 Y.1) √ó (D.Hom X.2 Y.2)

-- defining the identity functor on an object in C √ó D
def PrdObjIdn (C : category) (D : category) (X : PrdObjObj C D) := ((C.Idn X.1),(D.Idn X.2))

-- defining the composition on morphisms in C √ó D
def PrdObjCmp (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (Z : PrdObjObj C D) (f : PrdObjHom C D X Y) (g : PrdObjHom C D Y Z) : PrdObjHom C D X Z := (g.1 ‚àò f.1, g.2 ‚àò f.2)


-- proving the first identity law for morphisms in C √ó D 
theorem PrdObjId‚ÇÅ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  PrdObjCmp C D X Y Y f (PrdObjIdn C D Y) = f  := sorry

/-
-- Eq.trans (PrdObjId‚ÇÅ‚ÇÄ C D X Y f) (Eq.trans (PrdObjId‚ÇÅ‚ÇÅ C D X Y f) (PrdObjId‚ÇÅ‚ÇÇ C D X Y f))

theorem PrdObjId‚ÇÅ‚ÇÄ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  PrdCmp C D X Y Y f (PrdIdn C D Y) = (C.Cmp X.1 Y.1 Y.1 f.1 (C.Idn Y.1), D.Cmp X.2 Y.2 Y.2 f.2 (D.Idn Y.2)) := Eq.refl (C.Cmp X.1 Y.1 Y.1 f.1 (C.Idn Y.1), D.Cmp X.2 Y.2 Y.2 f.2 (D.Idn Y.2))
theorem PrdObjId‚ÇÅ‚ÇÅ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  (C.Cmp X.1 Y.1 Y.1 f.1 (C.Idn Y.1), D.Cmp X.2 Y.2 Y.2 f.2 (D.Idn Y.2)) = (f.1, f.2) :=
  by rw [show (f.fst, f.snd) = _ by rw [‚Üê C.Id‚ÇÅ X.1 Y.1 f.1, ‚Üê D.Id‚ÇÅ X.2 Y.2 f.2]]
theorem PrdObjId‚ÇÅ‚ÇÇ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  (f.1, f.2) = f := Eq.refl f
-/


-- proving the second identity law for morphisms in C √ó D 
theorem PrdObjId‚ÇÇ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) : PrdObjCmp C D X X Y (PrdObjIdn C D X) f = f  := sorry
/-
-- Eq.trans (PrdObjId‚ÇÇ‚ÇÄ C D X Y f) (Eq.trans (PrdId‚ÇÇ‚ÇÅ C D X Y f) (PrdId‚ÇÇ‚ÇÇ C D X Y f))
theorem PrdId‚ÇÇ‚ÇÄ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  PrdCmp C D X X Y (PrdIdn C D X) f = (C.Cmp X.1 X.1 Y.1 (C.Idn X.1) f.1, D.Cmp X.2 X.2 Y.2 (D.Idn X.2) f.2) := 
  Eq.refl (C.Cmp X.1 X.1 Y.1 (C.Idn X.1) f.1, D.Cmp X.2 X.2 Y.2 (D.Idn X.2) f.2)
theorem PrdId‚ÇÇ‚ÇÅ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  (C.Cmp X.1 X.1 Y.1 (C.Idn X.1) f.1, D.Cmp X.2 X.2 Y.2 (D.Idn X.2) f.2) = (f.1, f.2) :=
  by rw [show (f.fst, f.snd) = _ by rw [‚Üê C.Id‚ÇÇ X.1 Y.1 f.1, ‚Üê D.Id‚ÇÇ X.2 Y.2 f.2]]
theorem PrdId‚ÇÇ‚ÇÇ (C : category) (D : category) (X : PrdObjObj C D) (Y : PrdObjObj C D) (f : PrdObjHom C D X Y) :
  (f.1, f.2) = f := Eq.refl f
-/


-- proving associativity for morphisms in C √ó D
theorem PrdObjAss (C : category) (D : category) (W : PrdObjObj C D) (X : PrdObjObj C D) (Y : PrdObjObj C D) (Z : PrdObjObj C D) (f : PrdObjHom C D W X) (g : PrdObjHom C D X Y) (h : PrdObjHom C D Y Z) : PrdObjCmp C D W X Z f (PrdObjCmp C D X Y Z g h) = PrdObjCmp C D W Y Z (PrdObjCmp C D W X Y f g) h := sorry


-- defining the PrdObj of two categories
def PrdObj (C : category) (D : category) : category := {Obj := PrdObjObj C D, Hom := PrdObjHom C D, Idn := PrdObjIdn C D, Cmp := PrdObjCmp C D, Id‚ÇÅ := PrdObjId‚ÇÅ C D, Id‚ÇÇ:= PrdObjId‚ÇÇ C D, Ass := PrdObjAss C D}


notation C "‚®Ø_Cat" D => PrdObj C D


-- defining natural transformations for a category C and a category D
structure HomObjHom (C : category) (D : category) (F : functor C D) (G : functor C D) where
  Obj : (X : C.Obj) ‚Üí (D.Hom (F.Obj X) (G.Obj X))
  Nat : (X : C.Obj) ‚Üí (Y : C.Obj) ‚Üí (f : C.Hom X Y) ‚Üí ((Obj Y) ‚àò (F.Hom X Y f) ) = ((G.Hom X Y f) ‚àò (Obj X))


-- notation for natural transformations
def natural_transformation {C : category} {D : category} (F : functor C D) (G : functor C D) := HomObjHom C D F G
notation F "‚á®" G => natural_transformation F G


-- defining (Hom C D).Idn.Obj for a category C and a category D
def HomObjIdnObj (C : category) (D : category) (F : functor C D) (X : C.Obj) : (D.Hom (F.Obj X) (F.Obj X)) := D.Idn (F.Obj X)

-- defining (Hom C D).Idn.Nat for a category C and a category D
def HomObjIdnNat (C : category) (D : category) (F : functor C D) (X : C.Obj) (Y : C.Obj) (f : C.Hom X Y) : ((HomObjIdnObj C D F Y) ‚àò (F.Hom X Y f)) = ((F.Hom X Y f) ‚àò (HomObjIdnObj C D F X)) := sorry

-- defining (Hom C D).Idn for a category C and a category D
def HomObjIdn (C : category) (D : category) (F : functor C D) : HomObjHom C D F F := {Obj := HomObjIdnObj C D F, Nat := HomObjIdnNat C D F}


-- defining (Hom C D).Cmp for a category C and a category D
def HomObjCmp (C : category) (D : category) (F : functor C D) (G : functor C D) (H : functor C D) (f : HomObjHom C D F G) (g : HomObjHom C D G H) : HomObjHom C D F H := sorry


-- defining (Hom C D).Id‚ÇÅ
def HomObjId‚ÇÅ (C : category) (D : category) (F : functor C D) (G : functor C D) (f : HomObjHom C D F G) : HomObjCmp C D F G G f (HomObjIdn C D G) = f := sorry

-- defining (Hom C D).Id‚ÇÇ
def HomObjId‚ÇÇ (C : category) (D : category) (F : functor C D) (G : functor C D) (f : HomObjHom C D F G) : HomObjCmp C D F F G (HomObjIdn C D F) f = f := sorry

-- defining (Hom C D).Ass
def HomObjAss (C : category) (D : category) (F : functor C D) (G : functor C D) (H : functor C D) (I : functor C D) (Œ± : HomObjHom C D F G) (Œ≤ : HomObjHom C D G H) (Œ≥ : HomObjHom C D H I) : (HomObjCmp C D F G I Œ± (HomObjCmp C D G H I Œ≤ Œ≥)) = (HomObjCmp C D F H I (HomObjCmp C D F G H Œ± Œ≤) Œ≥) := sorry


-- defining the category Hom C D for a category C and a category D
def HomObj (C : category) (D : category) : category := {Obj := functor C D, Hom := HomObjHom C D, Idn := HomObjIdn C D, Cmp := HomObjCmp C D, Id‚ÇÅ := HomObjId‚ÇÅ C D, Id‚ÇÇ := HomObjId‚ÇÇ C D, Ass := HomObjAss C D}


notation "[" C "," D "]_Cat" => HomObj C D


--  defining F √ó C on objects
def PrdHomObj (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) (X : PrdObjObj C D‚ÇÅ) : PrdObjObj C D‚ÇÇ := (X.1, F.Obj X.2)

--  defining F √ó C on morphisms
def PrdHomHom (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) (G : C ‚ûû D‚ÇÅ) (H : C ‚ûû D‚ÇÅ) (g : G ‚á® H) : ((F ‚Ä¢ G) ‚á® (F ‚Ä¢ H)) := sorry


--  proving the identity law for F √ó C
-- def PrdHomIdn (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) (P : PrdObj C D‚ÇÅ) : PrdHom := sorry 

--  proving the compositionality law for F √ó C
-- def PrdHomCmp (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) (G‚ÇÅ : C ‚ûû D‚ÇÅ) (G‚ÇÇ : C ‚Üí D‚ÇÅ) (G‚ÇÉ : C ‚Üí D‚ÇÅ) (g‚ÇÅ : G‚ÇÅ ‚á® G‚ÇÇ) (g‚ÇÇ : G‚ÇÇ ‚á® G‚ÇÉ) : ??? := sorry 


-- defining (Prd C).Hom F
-- def PrdHom (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) : (PrdObjObj C D‚ÇÅ) ‚ûû (PrdObjObj C D‚ÇÇ) := {Obj := PrdHomObj, Hom := PrdHomHom, Idn := PrdHomIdn, Cmp := PrdHomCmp}


-- proving the identity law for Prd C
-- def PrdIdn (C : category) (D : category) : PrdHom C (ùü≠ D) = ùü≠ (PrdHom C D) := sorry

--  proving the compositionality law for - √ó_Cat C 
--  def PrdCmp (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (D‚ÇÉ : category) (F‚ÇÅ : D‚ÇÅ ‚ûû D‚ÇÇ) (F‚ÇÇ : D‚ÇÇ ‚ûû D‚ÇÉ) : ((PrdHom C F‚ÇÇ) ‚Ä¢ (PrdHom C F‚ÇÅ)) = (F‚ÇÇ ‚Ä¢ F‚ÇÅ) := sorry


-- defining the functor C ‚®Ø - : Cat ‚ûû Cat
def Prd (C : category) : Cat ‚ûû Cat := sorry -- {Obj := PrdObj C, Hom := PrdHom C, Idn := PrdIdn C, Cmp := PrdCmp C}


notation "-" "‚®Ø_Cat" C => Prd C


--  defining Hom C F on objects
def HomHomObj (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : functor D‚ÇÅ D‚ÇÇ) (G : functor C D‚ÇÅ) := Cat.Cmp C D‚ÇÅ D‚ÇÇ G F

-- defining Hom C F on morphisms
def HomHomHom (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : functor D‚ÇÅ D‚ÇÇ) (G‚ÇÅ : functor C D‚ÇÅ) (G‚ÇÇ : functor C D‚ÇÅ) (g : G‚ÇÅ ‚á® G‚ÇÇ) : (F ‚Ä¢ G‚ÇÅ) ‚á® (F ‚Ä¢ G‚ÇÇ) := sorry


-- proving the identity law for Hom C F
-- def HomHomIdn (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : functor D‚ÇÅ D‚ÇÇ) := sorry

--  proving the compositionality law for Hom C F
-- def HomHomCmp := sorry


-- defining Hom C F
-- def HomHom (C : category) (D‚ÇÅ : category) (D‚ÇÇ : category) (F : D‚ÇÅ ‚ûû D‚ÇÇ) : (HomObj C D‚ÇÅ) ‚ûû (HomObj C D‚ÇÇ) := sorry 


--  proving the identity law for Hom C
-- def HomIdn (C : category) () :  := sorry

--  proving the compositionality law for Hom C
--  def HomCmp (C : category) () :  := sorry


-- defining the functor Hom C : Cat ‚ûû Cat
def Hom (C : category) : Cat ‚ûû Cat := sorry


notation "[" "-" "," C "]_Cat" => Hom C


-- Defining the unit of the prd-hom adjunction
def Pair (C : category) : (ùü≠ Cat) ‚á® (Hom C) ‚Ä¢ (Prd C) := sorry


-- Defining the counit of the prd-hom adjunction
def Eval (C : category) : ((Prd C) ‚Ä¢ (Hom C)) ‚á® (ùü≠ Cat) := sorry


-- first triangle identity of the prd-hom adjunction
/-
-/


-- first triangle identity of the product-hom adjunction
/-
-/


-- Œµ : X √ó Y ‚ûû Y
def Term (X : category) : (Prd X) ‚á® (ùü≠ Cat) := sorry
notation "Œµ" => Term


-- Œî : X √ó Y ‚ûû X √ó X √ó Y
def Diag (X : category) : (Prd X) ‚á® ((Prd X) ‚Ä¢ (Prd X)) := sorry


-- notation for the comultiplication for product with X
notation "Œî" => Diag


-- proof of the first identity law of the comultiplication
/-

-/


-- proof of the second identity law of the comultiplication
/-

-/


-- proof of the coassociativity of the comultiplication
/-

-/


-- Construction of the unit for Hom X
def Const : (ùü≠ Cat) ‚á® (Hom X) := sorry


-- notation 
/-

-/


-- Construction of the multiplication for [X, -]
def double : (Hom X) ‚á® (Hom X) ‚Ä¢ (Hom X) := sorry


-- 
/-

-/



-- proving associativity for the comonad (Hom X)
/-

-/


-- proof of the commutativity of categorical Prd
def Tw‚ÇÅ (C : category) (D : category) : ((Prd C) ‚Ä¢ (Prd D)) ‚á® ((Prd D) ‚Ä¢ (Prd C)) := sorry


-- notation "œÑ‚ÇÅ" => Tw‚ÇÅ


-- proving that the twist map is its own inverse
-- def (C : category) (D : category) : (œÑ ‚àò œÑ = (Idn (C ‚®Ø D))) := sorry


-- defining the twist map (Hom X) ‚Ä¢ (Hom Y) ‚âÖ (Hom Y) ‚Ä¢ (Hom X)
def Tw‚ÇÇ (C : category) (D : category) : ((Hom C) ‚Ä¢ (Hom D)) ‚á® ((Hom D) ‚Ä¢ (Hom C)) := sorry
-- notation "œÑ‚ÇÇ" => Twist


-- proof that the twist map is its own inverse
-- def (C : category) (D : category) : (œÑ ‚àò œÑ = (Idn (C ‚®Ø D))) := sorry


-- defining the category ‚äõ
def PntObj : Type := Unit
def PntHom (_ : PntObj) (_ : PntObj) : Type := Unit
def PntIdn (X : PntObj) : PntHom X X := Unit.unit
def PntCmp (X : PntObj) (Y : PntObj) (Z : PntObj) (_ : PntHom X Y) (_ : PntHom Y Z) : PntHom X Z := Unit.unit
def PntId‚ÇÅ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X Y Y f (PntIdn Y) = f := sorry
def PntId‚ÇÇ (X : PntObj) (Y : PntObj) (f : PntHom X Y) : PntCmp X X Y (PntIdn X) f = f := sorry
def PntAss (W : PntObj) (X : PntObj) (Y : PntObj) (Z : PntObj) (f : PntHom W X) (g : PntHom X Y) (h : PntHom Y Z) : PntCmp W Y Z (PntCmp W X Y f g) h = PntCmp W X Z f (PntCmp X Y Z g h) := sorry
def Pnt : category := {Obj := PntObj, Hom := PntHom, Idn := PntIdn, Cmp := PntCmp, Id‚ÇÅ := PntId‚ÇÅ, Id‚ÇÇ := PntId‚ÇÇ, Ass := PntAss}


-- notation for the category ‚äõ
notation "‚äõ" => Pnt


-- defining (Prd ‚äõ) ‚á® (ùü≠ Cat)


-- defining (ùü≠ Cat) ‚á® (Prd ‚äõ)


-- proving the first inverse identity


-- proving the second inverse identity


-- defining (Hom ‚äõ) ‚á® (ùü≠ Cat)
-- def IdnHomObj (C : category) : Hom ‚äõ C 
-- def IdnHomHom 
-- def IdnHomIdn
-- def IdnHomCmp


-- defining (ùü≠ Cat) ‚á® (Hom ‚äõ)
-- def IdnHom
-- def 
-- def 
-- def Idn


-- proving the first inverse identity


-- proving the second inverse identity
-- def Hom ‚äõ ‚âÖ X


-- Defining the Prd F √ó G of two Hom one way
def FunPrd‚ÇÅ {C‚ÇÅ : category} {C‚ÇÇ : category} {D‚ÇÅ : category} {D‚ÇÇ : category} (F : C‚ÇÅ ‚ûû C‚ÇÇ) (G : D‚ÇÅ ‚ûû D‚ÇÇ) : (PrdObj C‚ÇÅ D‚ÇÅ) ‚ûû (PrdObj C‚ÇÇ D‚ÇÇ) := sorry


-- Defining the Prd F √ó G of two Hom the other way
def FunPrd‚ÇÇ {C‚ÇÅ : category} {C‚ÇÇ : category} {D‚ÇÅ : category} {D‚ÇÇ : category} (F : C‚ÇÅ ‚ûû C‚ÇÇ) (G : D‚ÇÅ ‚ûû D‚ÇÇ) : (PrdObj C‚ÇÅ D‚ÇÅ) ‚ûû (PrdObj C‚ÇÇ D‚ÇÇ) := sorry


-- Showing that the two Prds are equal
theorem FunPrdEqn {C‚ÇÅ : category} {C‚ÇÇ : category} {D‚ÇÅ : category} {D‚ÇÇ : category} (F : C‚ÇÅ ‚ûû C‚ÇÇ) (G : D‚ÇÅ ‚ûû D‚ÇÇ) : FunPrd‚ÇÅ F G = FunPrd‚ÇÇ F G := sorry


-- notation for the functor Prd
notation F "‚®Ø" G => FunPrd‚ÇÅ F G


-- Defining the canonical map in the universal property of Prd
-- def 


-- Proving the uniqueness of the canonical map in the universal property of Prd
/-
theorem (uniqueness of the canonical map)
-/


-- 
/-

-/


-- definition of a (strict) twocategory
structure twocategory where
  TwoObj : Type
  TwoHom : TwoObj ‚Üí TwoObj ‚Üí category
  TwoIdn : (C : TwoObj) ‚Üí ‚äõ ‚ûû (TwoHom C C)
  TwoCmp : (C : TwoObj) ‚Üí (D : TwoObj) ‚Üí (E : TwoObj) ‚Üí (PrdObj (TwoHom C D) (TwoHom D E)) ‚ûû (TwoHom C E)
--  TwoId‚ÇÅ : (C : Obj) ‚Üí (D : Obj) ‚Üí (TwoCmp C D D) ‚Ä¢ ((Idn 1) ‚®Ø (ùü≠ )) = 
--  TwoId‚ÇÇ : (C : Obj) ‚Üí (D : Obj) ‚Üí (Cmp C C D) ‚Ä¢ ((Idn D) √ó 1) = 
--  Ass : (B : Obj) ‚Üí (C : Obj) ‚Üí (D : Obj) ‚Üí (E : Obj) ‚Üí (((Cmp B C E) ‚Ä¢ (FunPrd‚ÇÅ (ùü≠ (Hom B C)) (Cmp C D E))) = (Cmp B D E ‚Ä¢ (FunPrd‚ÇÅ (Cmp B C D) (ùü≠ (Hom D E)))))


-- notation for a twocategory
/-

-/


-- defining categories.Idn.Obj
def TwoIdnObj (C : category) (_ : Unit) := Cat.Idn C


-- defining the functor categories.Idn.Hom on morphisms
def TwoIdnHom (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (HomObj C C).Idn (Cat.Idn C)


-- proving the identity law for the functor categories.TwoIdn
-- def TwoIdnIdn (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (HomObj C C).Idn (Cat.Idn C)


-- proving compositionality for the functor categories.TwoIdn
-- def Two.Idn.Cmp (C : category) (_ : Unit) (_ : Unit) (_: Unit) := (HomObj C C).Idn (Cat.Idn C)


-- def categories.Idn
def TwoIdn (C : category) : ‚äõ ‚ûû (HomObj C C) := sorry


--  defining Two.Cmp.Obj
/-
-/


--  defining Two.Cmp.Hom
/-
def TwoTwoHom (C : Obj) (D : Obj) (E : Obj)  : FG.1 FG.2
def TwoTwoHom (C : Obj) (D : Obj) (E : Obj) (f : ((Hom C D) ‚®Ø (Hom D E)).Hom )
def CatsHom (C : Obj) (D : Obj) (E : Obj) 
(F‚ÇÅG‚ÇÅ : ((Hom C D) ‚®Ø (Hom D E)).Obj) (F‚ÇÇG‚ÇÇ : ((Hom C D) ‚®Ø (Hom D E)).Obj)
-/



-- proving the identity law equation for Two.TwoCmp
/-
def 
-/


-- proving compositionality for the functor Two.Cmp
-- def TwoCmpCmp : (C : category) ‚Üí (D : category) ‚Üí (E : category) ‚Üí (PrdObj (HomObj C D) (HomObj D E)) ‚ûû (HomObj C E) := sorry


--  Two.Cmp : (C : Obj) ‚Üí (D : Obj) ‚Üí (E : Obj) ‚Üí (Hom C D) √ó (Hom D E) ‚ûû (Hom C E)    
def TwoCmp : (C : category) ‚Üí (D : category) ‚Üí (E : category) ‚Üí (PrdObj (HomObj C D) (HomObj D E)) ‚ûû (HomObj C E) := sorry


--  Id‚ÇÅ : (C : Obj) ‚Üí (D : Obj) ‚Üí (Cats.Id‚ÇÅ)
/-
def TwoId‚ÇÅ : (C : category) ‚Üí (D : category) ‚Üí (F : functor C D) ‚Üí 
-/


--  Id‚ÇÇ : (C : Obj) ‚Üí (D : Obj) ‚Üí (F : (Hom C D).Obj) ‚Üí ...      (Cats.Id‚ÇÅ)
/-
def TwoId‚ÇÇ : (C : category) ‚Üí (D : category) ‚Üí (F : functor C D) ‚Üí 
-/


-- proving associativity of composition for the twocategory of Two
/-
def TwoAss
-/


-- notation for horizontal composition
/-
class horizontal_composition (C : category) (D : category) (E : category) (F‚ÇÅ : C ‚ûû D) (F‚ÇÇ : C ‚Üí D) (G‚ÇÅ : D ‚Üí D) (G‚ÇÇ : D ‚Üí E) where
  f : (F‚ÇÅ ‚á® F‚ÇÇ) ‚Üí (G‚ÇÅ ‚á® G‚ÇÇ) ‚Üí ((G‚ÇÅ ‚Ä¢ F‚ÇÅ) ‚á® (G‚ÇÇ ‚Ä¢ F‚ÇÇ)) 

def f (p : Prop) : Prop := ¬¨p
def g (n : Nat): Nat := n + 1
-/


/-
class Elephant (T : Type) where
  fn : T ‚Üí T

instance prop_elephant : Elephant Prop where
  fn := f

instance int_elephant : Elephant Nat where
  fn := g

def elephant {T : Type} [E : Elephant T] (t : T) : T := E.fn t

#check elephant (2 : Nat)
#reduce elephant (2 : Nat)
#eval elephant (2 : Nat)

#check elephant True
#reduce elephant True

#check elephant (0 : Nat)

notation "ìÉ∞" t => elephant t
#eval ìÉ∞ (2 : Nat)
-/


/-
class composition (C : category) (D : category) (F : functor C D) (X : Type p‚ÇÅ) (Y : Type p‚ÇÇ) (T : Type p‚ÇÅ ‚Üí Type p‚ÇÇ ‚Üí Type p‚ÇÉ) (Z : T X Y) where
  f : X ‚Üí Y ‚Üí Z

instance functor_application_on_objects (C : category) (D : category) : composition (functor C D) C.Obj (Type p‚ÇÉ) D.Obj where
  f := fun(F : functor C D) => fun(X : C.Obj) => F.Obj X

instance functor_application_on_morphisms (C : category) (D : category) (X : C.Obj) (Y : C.Obj) : composition (functor C D) () () where
  f := 

instance functor_composition

instance natural_transformation_whisker‚ÇÅ

instance natural_transformation_whisker‚ÇÇ

instance horizontal_composition 

-/

/-
notation X √ó Y => horizontal_composition X Y


notation "ìÉ∞" t => elephant t
#eval ìÉ∞ (2 : Nat)
-/


-- definition of the yoneda embedding
def yoneda_embedding (C : category) : C·µí·µñ ‚ûû Set := sorry


-- notation for the Yoneda embedding
notation "„Çà" => yoneda_embedding


-- definition of the contravariant yoneda embedding
/-

-/


/-
def (C : category) (F : C·µí·µñ ‚á® Set) : [X, -] ‚á® F ‚âÖ F ‚Ä¢ X := sorry
-/


/-
def (C : category) (F : C·µí·µñ ‚á® Set) : [X, -] ‚á® F ‚âÖ F ‚Ä¢ X := sorry
-/


/-
def ([X, -] ‚á® [Y, -]) ‚âÖ [X, Y]
-/


/-
def ([-, X] ‚á® [-, Y]) ‚âÖ [Y, X]
-/


-- corollary: the Yoneda embedding is full
/-

-/


-- corollary: the Yoneda embedding is faithful
/-

-/


-- corollary: the contravariant Yoneda embedding is full and faithful
/-

-/


-- definition of an adjunction
structure adjunction where
  C : category
  D : category
  F  : C ‚ûû D
  G  : D ‚ûû C
  Unit  : (ùü≠ C) ‚á® (G ‚Ä¢ F)
  Counit  : (F ‚Ä¢ G) ‚á® (ùü≠ D) 
 -- œÑ‚ÇÅ  : ((ùü≠ F) ‚àô Œ∑)  =  ((ùü≠ F) ‚àô Œ∑)   -- ‚àò (Iso (‚ÑÇùïíùï•.Hom Dom Cod) (Ass F G F)) ‚àò (((CatHom C D).Idn F) ‚Ä¢ Œ∑)) = (CatHom D C).Idn left
--  œÑ‚ÇÇ  : (ùüô F) = (ùüô F)   -- ‚àò (Iso (‚ÑÇùïíùï•.Hom Dom Cod) (Ass F G F)) ‚àò (((CatHom C D).Idn F) ‚Ä¢ Œ∑)) = (CatHom D C).Idn left


-- notation for an adjunction
/-
notation C "" D => adjoint C D --adjoint symbol
def F (U : TwoCat) {C : U.Obj} {D : U.Obj} (f : Adj C D) := f.F

notation f "‡•±" => F f

def G (U : TwoCat) {C : U.Obj} {D : U.Obj} (f : Adj C D) := f.G
notation f "õ≤î" => G f

def adjoint {C : category} {D : category} (F : )...

notation F "‚ä£" G => adjoint 
-/


-- definition of a monad
structure monad where
  C : category
  T : C ‚ûû C
  Unit : (ùü≠ C) ‚á® T
  Mult : (T ‚Ä¢ T) ‚á® T
--  Id‚ÇÅ  : Œº ‚àò (Œ∑ ‚àô (ùüô T)) = ùüô T
--  Id‚ÇÇ  : Œº ‚àò ((ùüô T) ‚Ä¢ Œ∑) = ùüô T
--  Ass  : Œº ‚àò (Œº ‚Ä¢ (ùüô T)) = Œº ‚àò ((ùüô T) ‚Ä¢ Œº)


-- notation for a monad
/- 
-- notation for monad application
instance comonad_application {C : CatObj} : horizontalCmp (Com C) (Obj C) (Obj C) where
  œÜ := fun(T‚ÇÄ : Com C)=>fun(X‚ÇÄ : Obj C)=>(T‚ÇÄ.functor.Obj X‚ÇÄ)
-/


-- definition of a comonad (shouldn't depend on a twocat)
structure comonad where
  C : category
  T : C ‚ûû C
  Counit : T ‚á® (ùü≠ C)
  Comult : T ‚á® (T ‚Ä¢ T) 
--  Id‚ÇÅ  : (Unt √ó (Idn T)) ‚Ä¢ Comul  = (Idn T)
--  Id‚ÇÇ  : ((Idn T) √ó Unt) ‚Ä¢ Comul  = (Idn T)
--  Ass  : (Mul √ó (Idn T)) ‚Ä¢ (Idn T) = ((Idn T) √ó Mul) ‚Ä¢ (Idn T)



-- notation for a comonad
/-
def Unit {C : category} (M : comonad C) := M.Counit
notation "œÑ" M => Counit M

def ult {C : category} (M : comonad C) := M.Comult
notation "Œ¥" M => Mlt M

-- notation for monad application
instance comonad_application {C : category} : horizontalCmp (Com C) (Obj C) (Obj C) where
  œÜ := fun(T‚ÇÄ : Com C)=>fun(X‚ÇÄ : Obj C)=>(T‚ÇÄ.functor.on_objects X‚ÇÄ)
-- œÑ‚ÇÅ
-- œÑ‚ÇÇ
-- Œ≥
-/


-- the monad corresponding to an adjunction
-- def 



-- notation for the monad corresponding to an adjunction
/-
notation
-/


-- canonical map from eilenberg moore category of the corresponding monad for an adjunction
/-
def
-/


-- notation for the canonical map from eilenberg moore category of the corresponding monad for an adjunction
/-
notation ?
-/


-- the eilenberg moore adjunction unit 
/-
def 
-/


-- eilenberg moore adjunction triangle identity 1
/-
theorem
-/


-- eilenberg moore adjunction triangle identity 2
/-
theorem
-/

-- LEAN: def when ! is an iso (monadicity)
/-
def Monadic (f : Adj) : Prop := sorry
-/
-- defining premonadicity
/-
def Premonadic (f : Adj) : Prop := sorry
-/

-- the comonad corresponding to an adjunction
/-
def
-/


-- notation for the comonad corresponding to an adjunction
/-
notation !
-/


-- canonical map into the coeilenberg comoore category of the corresponding comonad
/-
def
-/


-- notation for canonical map into coeilenberg comoore category of the corresponding monad for an adjunction
/-
notation ?
-/


-- the coeilenberg comoore adjunction unit
/-
def
-/


-- the coeilenberg comoore adjunction counit
/-
def
-/


-- coeilenberg comoore adjunction triangle identity 1
/-
theorem
-/


-- coeilenberg comoore adjunction triangle identity 2
/-
theorem
-/

-- defining when ? is an iso (comonadicity)
/-
def Comonadic (f : Adj) : Prop := sorry
-/
-- defining precomonadicity
/-
def Precomonadic (f : Adj) : Prop := sorry
-/

/-
structure bijunction (C : category) (D : category) where
  C : category
  D : category
  B : C ‚ûû D
  L : D ‚ûû C
  R : D ‚ûû C
-- counit of L ‚ä£ B
-- unit of L ‚ä£ B
-- tr 1 of L ‚ä£ B
-- tr 2 of L ‚ä£ B
-- counit of B ‚ä£ R
-- unit of B ‚ä£ R
-- tr 1 of L ‚ä£ B
-- tr 2 of L ‚ä£ B
-- comonadicity of L ‚ä£ B
-- monadicity of B ‚ä£ R
-- commutativity 
-- 
-/


structure representation where
  Obj : category
  Geo : Obj.Obj
-- Pull : bijunction Obj Bij
-- Push : bijunction Obj·µí·µñ Bij
-- Id‚ÇÅ : 
-- Id‚ÇÇ : 
-- Ass : 
-- 
-- Hom Geo ‚âÖ 
-- Prd Geo ‚âÖ 
-- homotopy pullback of identity and identity is representable by the geodesic

/-
there should be an identity ‚äõ
[Œ≥,-]
product with the geodesic should represent directed homotopy pushout
-/


/-
here the pullback is itself commutative
-/


/-
definition of product on objects
-/


/-
definition of product on hom
-/


/-
proof of the identity law for product
-/


/-
proof of compositionality for product
-/


/-
definition of coproduct on objects
-/


/-
definition of coproduct on hom
-/


/-
proof of the identity law for coproduct
-/


/-
proof of compositionality for coproduct
-/


-- definition of the objects of the category ‚áâ
/-

-/

-- definition of ‚Ñï.Hom of the category ‚áâ
/-

-/


-- definition of Idn in the category ‚áâ
/-

-/


-- definition of Cmp in the category ‚áâ
/-

-/



-- proving the first identity law of the objects of the category ‚Ñï
/-

-/

-- proving the second identity law of the objects of the category ‚Ñï
/-

-/


-- proving associativity of the objects of the category ‚Ñï
/-

-/



-- defining the category ‚áâ
def Par : category := sorry


-- notation for the category ‚áâ
/-
notation "‚áâ" => Par
-/


-- limit as an equilizer of products
/-

-/


-- colimit as an coequilizer of coproducts
/-

-/


/-
definition of equilizer on objects
-/


/-
definition of equilizer on morphisms
-/


/-
definition of the identity law for equilizer
-/


/-
definition of the compositionality law for equilizer
-/


/-
definition of the equilizer
-/


/-
definition of coequilizer on objects
-/


/-
definition of coequilizer on morphisms
-/


/-
definition of the identity law for coequilizer
-/


/-
definition of the compositionality law for coequilizer
-/


/-
definition of the coequilizer
-/


/-
definition of equilizer on objects
-/


/-
definition of equilizer on morphisms
-/


/-
definition of the identity law for equilizer
-/


/-
definition of the compositionality law for equilizer
-/


-- def equilizer


/-
definition of coequilizer on objects
-/


/-
definition of coequilizer on morphisms
-/


/-
definition of the identity law for coequilizer
-/


/-
definition of the compositionality law for coequilizer
-/


/-
definition of the coequilizer
-/


-- objects for the pullback representation in the category of categories
/-

-/


-- the pullback representation in the category of categories
/-

-/


-- the pullback representation in the category of categories
/-

-/


-- the pullback representation in the category of categories
/-

-/


-- the pullback representation in the category of categories
/-

-/


-- the pullback representation in the category of categories
/-

-/


-- the pushout representation in the opposite category of categories
/-

-/


-- definition of the objects of the category ‚Ñï
/-

-/

-- definition of ‚Ñï.Hom of the category ‚Ñï
/-

-/


-- definition of Idn in the category ‚Ñï
/-

-/


-- definition of Cmp in the category ‚Ñï
/-

-/



-- proving the first identity law of the objects of the category ‚Ñï
/-

-/

-- proving the second identity law of the objects of the category ‚Ñï
/-

-/


-- proving associativity of the objects of the category ‚Ñï
/-

-/



-- defining the category ‚Ñï
/-

-/

